beta = c1,
wts = wgt
)
wgt2 = rep(1, NN)
wgt2[which(c1[1,1,] <0.5)] = 50
wgt2 = wgt2 / sum(wgt2)
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
par(mfrow=c(1,2));
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output2$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
betamean
output$len
output$len*wgt
output$len^wgt
(output$len^wgt)^(1/length(output$len))
output$mean_scale
prod(output$len^wgt)^(1/length(output$len))
library(fdasynthesis)
NN = length(which(clust_labels2 == "10"))
c1 = fun_array_2[ , , which(clust_labels2 == "10")]
wgt = rep(1, NN)
wgt = wgt / sum(wgt)
output = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt
)
wgt2 = rep(1, NN)
wgt2[which(c1[1,1,] <0.5)] = 50
wgt2 = wgt2 / sum(wgt2)
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
par(mfrow=c(1,2));
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output2$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
prod(output$len)^(1/length(output$len))
output$mean_scale
prod(output$len ^ wgt)
library(fdasynthesis)
NN = length(which(clust_labels2 == "10"))
c1 = fun_array_2[ , , which(clust_labels2 == "10")]
wgt = rep(1, NN)
wgt = wgt / sum(wgt)
output = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt
)
wgt2 = rep(1, NN)
wgt2[which(c1[1,1,] <0.5)] = 50
wgt2 = wgt2 / sum(wgt2)
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
par(mfrow=c(1,2));
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output2$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
matplot(output$beta[1,,], col = 'blue', type = 'l')
matlines(output$betamean[1,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[1,], col = 'green', type='l', lwd=2)
wgt2[which(c1[1,1,] <0.5)] = 5000
wgt2 = wgt2 / sum(wgt2)
wgt2
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
wgt
wgt2
output$len ^ wgt2
output$len
prod(output$len ^ wgt2)
library(fdasynthesis)
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
wgt2 = rep(1, NN)
wgt2[which(c1[1,1,] <0.5)] = 5000
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
par(mfrow=c(1,2));
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output2$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
matplot(output$beta[1,,], col = 'blue', type = 'l')
matlines(output$betamean[1,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[1,], col = 'green', type='l', lwd=2)
NN = length(which(clust_labels2 == "10"))
c1 = fun_array_2[ , , which(clust_labels2 == "10")]
wgt = rep(1, NN)
wgt = wgt / sum(wgt)
output = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt
)
wgt2 = rep(1, NN)
wgt2[which(c1[1,1,] <0.5)] = 5000
wgt2 = wgt2 #/ sum(wgt2)
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
library(fdasynthesis)
par(mfrow=c(1,2));
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output2$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
matplot(output$beta[1,,], col = 'blue', type = 'l')
matlines(output$betamean[1,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[1,], col = 'green', type='l', lwd=2)
wgt2
output2$mean_scale
output = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt
)
par(mfrow=c(1,2));
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
View(output2)
View(output)
output2$len ^ wgt
output2$len ^ wgt2Ã¹
output2$len ^ wgt2
output2$len ^ (wgt2/sum(wgt2)
)
library(fdasynthesis)
NN = length(which(clust_labels2 == "10"))
c1 = fun_array_2[ , , which(clust_labels2 == "10")]
wgt = rep(1, NN)
# wgt = wgt / sum(wgt)
output = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt
)
wgt2 = rep(1, NN)
wgt2[which(c1[1,1,] <0.5)] = 5000
wgt2 = wgt2 #/ sum(wgt2)
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
par(mfrow=c(1,2));
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output2$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
matplot(output$beta[1,,], col = 'blue', type = 'l')
matlines(output$betamean[1,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[1,], col = 'green', type='l', lwd=2)
NN = length(which(clust_labels2 == "10"))
c1 = fun_array_2[ , , which(clust_labels2 == "10")]
wgt = rep(1, NN)
# wgt = wgt / sum(wgt)
output = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt
)
par(mfrow=c(1,2));
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output2$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
matplot(output$beta[1,,], col = 'blue', type = 'l')
matlines(output$betamean[1,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[1,], col = 'green', type='l', lwd=2)
output$cent
betamean_1 = output$betamean[1,] + weighted.mean(output$cent[1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
par(mfrow=c(1,2));
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(output$cent[1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_1 = output$betamean[1,] - weighted.mean(output$cent[1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
output = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt
)
library(fdasynthesis)
par(mfrow=c(1,2));
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
output$a
x = fdasrvf::q_to_curve(q = output$mu)
fdasynthesis:::calculate_centroid(x)
plot(x[1,,])
matplot(x[1,,])
matplot(x[1,])
matplot(x[1,], type='l')
matplot(x[1,] + weighted.mean(c1[1,1,], wgt), type='l')
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
matlines(x[1,] + weighted.mean(c1[1,1,], wgt), type='l', col='pink', lwd=3)
?repmat
?fdasynthesis:::repmat
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output2$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output2$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output2$beta[1,1,], wgt2)
betamean_2 = output2$betamean[1,] + weighted.mean(output$cent[1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output2$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
matlines(betamean_2, col='pink', type='l', lwd=3)
matplot(output$beta[1,,], col = 'blue', type = 'l')
matlines(output$betamean[1,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[1,], col = 'green', type='l', lwd=2)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
par(mfrow=c(1,2));
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(output$cent[1,], wgt2)
betamean_2 = output2$betamean[1,] + weighted.mean(output2$cent[1,], wgt2)
matlines(betamean_2, col='pink', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(output2$cent[1,], wgt2)
matlines(betamean_2, col='pink', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
matplot(c1[1,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(c1[1,1,] - output$beta[1,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
betamean_2 = output2$betamean[1,] + weighted.mean(output2$cent[1,], wgt2)
matlines(betamean_2, col='pink', type='l', lwd=3)
output2$betamean[1,] + weighted.mean(output2$cent[1,], wgt2)
betamean_2 = output2$betamean[1,] + weighted.mean(-output2$cent[1,], wgt2)
matlines(betamean_2, col='pink', type='l', lwd=3)
matplot(output$beta[1,,], col = 'blue', type = 'l')
matlines(output$betamean[1,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[1,], col = 'green', type='l', lwd=2)
+ weighted.mean(c1[1,1,] - output$beta[1,1,], wgt)
+ weighted.mean(output$beta[1,1,], wgt)
output2$betamean[1,]
output2$betamean[1,1]
for (l in 1:L) {
x11(); par(mfrow=c(1,2));
matplot(c1[l,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[1,] + weighted.mean(c1[l,1,] - output$beta[l,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[l,] + weighted.mean(c1[l,1,] - output$beta[l,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
# betamean_2 = output2$betamean[1,] + weighted.mean(-output2$cent[1,], wgt2)
# matlines(betamean_2, col='pink', type='l', lwd=3)
title("Original curves")
matplot(output$beta[l,,], col = 'blue', type = 'l')
matlines(output$betamean[l,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[l,], col = 'green', type='l', lwd=2)
title("Aligned curves")
}
graphics.off()
for (l in 1:L) {
x11(); par(mfrow=c(1,2));
matplot(c1[l,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[l,] + weighted.mean(c1[l,1,] - output$beta[l,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[l,] + weighted.mean(c1[l,1,] - output$beta[l,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
# betamean_2 = output2$betamean[1,] + weighted.mean(-output2$cent[1,], wgt2)
# matlines(betamean_2, col='pink', type='l', lwd=3)
title("Original curves")
matplot(output$beta[l,,], col = 'blue', type = 'l')
matlines(output$betamean[l,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[l,], col = 'green', type='l', lwd=2)
title("Aligned curves")
}
betamean_2 = output2$betamean[l,] -output2$betamean[l,1] + weighted.mean(c1[l,1,], wgt2)
for (l in 1:L) {
x11(); par(mfrow=c(1,2));
matplot(c1[l,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[l,] -output$betamean[l,1] + weighted.mean(c1[l,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=3)
betamean_2 = output2$betamean[l,] -output2$betamean[l,1] + weighted.mean(c1[l,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=3)
# betamean_2 = output2$betamean[1,] + weighted.mean(-output2$cent[1,], wgt2)
# matlines(betamean_2, col='pink', type='l', lwd=3)
title("Original curves")
matplot(output$beta[l,,], col = 'blue', type = 'l')
matlines(output$betamean[l,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[l,], col = 'green', type='l', lwd=2)
title("Aligned curves")
}
for (l in 1:L) {
x11(); par(mfrow=c(1,2));
matplot(c1[l,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[l,] -output$betamean[l,1] + weighted.mean(c1[l,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=1)
betamean_2 = output2$betamean[l,] -output2$betamean[l,1] + weighted.mean(c1[l,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=1)
# betamean_2 = output2$betamean[1,] + weighted.mean(-output2$cent[1,], wgt2)
# matlines(betamean_2, col='pink', type='l', lwd=3)
title("Original curves")
matplot(output$beta[l,,], col = 'blue', type = 'l')
matlines(output$betamean[l,], col = 'red', type='l', lwd=1)
matlines(output2$betamean[l,], col = 'green', type='l', lwd=1)
title("Aligned curves")
}
for (l in 1:L) {
x11(); par(mfrow=c(1,2));
matplot(c1[l,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[l,] -output$betamean[l,1] + weighted.mean(c1[l,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=2)
betamean_2 = output2$betamean[l,] -output2$betamean[l,1] + weighted.mean(c1[l,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=2)
# betamean_2 = output2$betamean[1,] + weighted.mean(-output2$cent[1,], wgt2)
# matlines(betamean_2, col='pink', type='l', lwd=3)
title("Original curves")
matplot(output$beta[l,,], col = 'blue', type = 'l')
matlines(output$betamean[l,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[l,], col = 'green', type='l', lwd=2)
title("Aligned curves")
}
output3 = fdasrvf::curve_karcher_mean(beta = c1, rotated = FALSE, scale = TRUE)
output3
output
View(output)
View(output3)
?fdasrvf::q_to_curve
NN = length(which(clust_labels2 == "5"))
c1 = fun_array_2[ , , which(clust_labels2 == "5")]
wgt = rep(1, NN)
output = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt
)
wgt2 = rep(1, NN)
wgt2[which(c1[1,1,] <0.5)] = 5000
wgt2 = wgt2 #/ sum(wgt2)
output2 = fdasynthesis:::weighted_karcher_mean(
beta = c1,
wts = wgt2
)
for (l in 1:L) {
x11(); par(mfrow=c(1,2));
matplot(c1[l,,], col = 'blue', type = 'l')
betamean_1 = output$betamean[l,] -output$betamean[l,1] + weighted.mean(c1[l,1,], wgt)
matlines(betamean_1, col='red', type='l', lwd=2)
betamean_2 = output2$betamean[l,] -output2$betamean[l,1] + weighted.mean(c1[l,1,], wgt2)
matlines(betamean_2, col='green', type='l', lwd=2)
# betamean_2 = output2$betamean[1,] + weighted.mean(-output2$cent[1,], wgt2)
# matlines(betamean_2, col='pink', type='l', lwd=3)
title("Original curves")
matplot(output$beta[l,,], col = 'blue', type = 'l')
matlines(output$betamean[l,], col = 'red', type='l', lwd=2)
matlines(output2$betamean[l,], col = 'green', type='l', lwd=2)
title("Aligned curves")
}
install.packages("devtools")
devtools::install_github("jdtuck/fdasrvf_R")
devtools::install_github("jdtuck/fdasrvf_R")
fdasynthesis:::compute_elastic_distance_one_set
fdasynthesis:::compute_elastic_distance_one_set
library(fdasynthesis)
# preparing the data
# setwd
wd_code = "C:/Users/Arianna/OneDrive - Politecnico di Milano/aa PhD/Virtual Curves/code"
setwd(wd_code)
representation = 'C_adj'
library(funData)
library(glue)
library(ggplot2)
library(dplyr)
# Trajectory data
load(file=glue('20231114_representation/20231207_data_representation{representation}.RData'))
N_traj = length(y0_fit)
source("Function__array_fill.R")
L = 3                   # L=n. dimensions of the function
M = length(x_interval)  # M=n. points on the evaluation grid (=length(x_interval))
N = N_traj              # N=n. functions
library(funData)
# array(N=curve, L=dimensioni curve, M=larghezza griglia) con le funzioni originali
fun_array = list_to_array(list(y0_fit, z0_fit, t0_fit) )
fun_mat = cbind(fun_array[,1,], fun_array[,2,], fun_array[,3,])
if (representation == 'C_adj') {names_y = c('easting', 'northing', 'time-to-end'); names_x = c('perc_time'); L=3}
fun_array_2 = list_to_array_2(array_to_list(fun_array))
start=Sys.time()
library(future)
library(progressr)
handlers("rstudio")
plan(multisession, workers = 8)
with_progress({
D_list = fdasynthesis:::compute_elastic_distance_one_set(
f_array = fun_array_2[1:3,,1:100], time = x_interval)
})
print(glue("Inizio ciclo 1 alle ore: {Sys.time()}"))
library(future)
library(progressr)
handlers("rstudio")
plan(multisession, workers = 8)
with_progress({
D_list = fdasynthesis:::compute_elastic_distance_one_set(
f_array = fun_array_2, time = x_interval)
})
plan(sequential)# 373.2937  mins previsti
save(D_list, fun_array_2, file="20240109_ShapeDistances_representationC_adj.RData")
print(glue("Finito ciclo 1 alle ore: {Sys.time()}"))
wd_code = "C:/Users/Arianna/OneDrive - Politecnico di Milano/aa PhD/Virtual Curves/code"
setwd(wd_code)
L=3
# install.packages("SPARTAAS")
if (L==3) load("20240109_ElasticDistances_representationC_adj.RData")
if (L==2) load("20231208_ElasticDistances_representationE.RData")
Dmat_a = D_list$Dy_tot
load("C:/Users/Arianna/OneDrive - Politecnico di Milano/aa PhD/Virtual Curves/code/20240109_ShapeDistances_representationC_adj.RData")
Dmat_a = D_list$Dy_tot
# attr(Dmat_a, "Labels") = 1:N
Dmat_p = D_list$Dx_tot
# attr(Dmat_p, "Labels") = 1:N
rm(D_list)
wd_code = "C:/Users/Arianna/OneDrive - Politecnico di Milano/aa PhD/Virtual Curves/code"
setwd(wd_code)
L=3
load("C:/Users/Arianna/OneDrive - Politecnico di Milano/aa PhD/Virtual Curves/code/20240109_ShapeDistances_representationC_adj.RData")
start = Sys.time()
print(start)
options(verbose = T)
output = SPARTAAS::hclustcompro_select_alpha(
D2=as.matrix(D_list$Dy_tot),
D1=as.matrix(D_list$Dx_tot),
acc=2,
resampling=TRUE,
method="complete",
iter=5
)
end = Sys.time()
print(end)
save (output, file='20240110_output_hclustcomb.RData')
output
1216/100
1216/100*5
end-start
(end-start)*10
(end-start)*10/24
start = Sys.time()
print(start)
options(verbose = T)
output = SPARTAAS::hclustcompro_select_alpha(
D2=as.matrix(D_list$Dy_tot),
D1=as.matrix(D_list$Dx_tot),
acc=2,
resampling=TRUE,
method="complete",
iter=50
)
start = Sys.time()
print(start)
options(verbose = T)
output = SPARTAAS::hclustcompro_select_alpha(
D2=as.matrix(D_list$Dy_tot),
D1=as.matrix(D_list$Dx_tot),
acc=2,
resampling=TRUE,
method="complete",
iter=50
)
end = Sys.time()
print(end)
save (output, file='20240111_output_hclustcomb.RData')
output
getwd()
